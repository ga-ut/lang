import ast
import parser
import typecheck
import cgen

type LineRes = { ok: bool, line: Str, next: i32 }
type ArgParse = { emit_c: Str, input: Str, err: i32 }

EXIT_OK: i32 = 0
EXIT_USAGE: i32 = 2
EXIT_INPUT_READ: i32 = 3
EXIT_EMIT_C_ARG: i32 = 4
EXIT_OUTPUT_WRITE: i32 = 5

scan_newline(s: Str, i: i32, n: i32) -> i32 =
  if !(copy i < copy n) then copy n else
  if str_byte_at(copy s, copy i) == 10 then copy i else
  scan_newline(copy s, copy i + 1, copy n)

read_line_at(s: Str, i: i32, n: i32) -> LineRes = {
  j: i32 = scan_newline(copy s, copy i, copy n)
  line: Str = str_slice(copy s, copy i, copy j - copy i)
  next: i32 = if copy j < copy n then copy j + 1 else copy n
  { ok: true, line: line, next: next }
}

read_line(s: Str, i: i32) -> LineRes = {
  n: i32 = str_len(copy s)
  if !(copy i < copy n) then { ok: false, line: "", next: copy i }
  else read_line_at(copy s, copy i, copy n)
}

parse_args_emit_c(s: Str, i: i32, emit_c: Str, input: Str, err: i32) -> ArgParse = {
  p: LineRes = read_line(copy s, copy i)
  ok: bool = copy p.ok
  next_p: i32 = copy p.next
  out: Str = if copy ok then p.line else emit_c
  next_i: i32 = if copy ok then next_p else copy i
  new_err: i32 = if copy ok then copy err else copy EXIT_EMIT_C_ARG
  parse_args_loop(copy s, next_i, out, input, new_err)
}

parse_args_build(s: Str, i: i32, emit_c: Str, input: Str, err: i32) -> ArgParse = {
  p: LineRes = read_line(copy s, copy i)
  ok: bool = copy p.ok
  next_p: i32 = copy p.next
  next_i: i32 = if copy ok then next_p else copy i
  parse_args_loop(copy s, next_i, emit_c, input, copy err)
}

parse_args_positional(
  s: Str, a: Str, next_i: i32, emit_c: Str, input: Str, err: i32
) -> ArgParse = {
  is_flag: bool = 0 < str_len(copy a) && str_byte_at(copy a, 0) == 45
  new_input: Str = if copy input == "" && !is_flag then a else copy input
  parse_args_loop(copy s, copy next_i, emit_c, new_input, copy err)
}

parse_args_dispatch(s: Str, r: LineRes, emit_c: Str, input: Str, err: i32) -> ArgParse = {
  next_i: i32 = copy r.next
  a: Str = r.line
  if copy a == "--emit-c" then parse_args_emit_c(copy s, copy next_i, copy emit_c, copy input, copy err)
  else if copy a == "--build" then parse_args_build(copy s, copy next_i, copy emit_c, copy input, copy err)
  else parse_args_positional(copy s, a, copy next_i, copy emit_c, copy input, copy err)
}

parse_args_loop(s: Str, i: i32, emit_c: Str, input: Str, err: i32) -> ArgParse = {
  r: LineRes = read_line(copy s, i)
  ok: bool = copy r.ok
  if !ok then { emit_c: copy emit_c, input: copy input, err: copy err }
  else parse_args_dispatch(copy s, r, emit_c, input, copy err)
}

parse_args() -> ArgParse = {
  argv: Str = bytes_to_str(args())
  // argv[0] skip
  first: LineRes = read_line(copy argv, 0)
  ok: bool = copy first.ok
  next_i: i32 = copy first.next
  start: i32 = if ok then next_i else 0
  parse_args_loop(copy argv, start, "", "", copy EXIT_OK)
}

compile_source(src: Str, out: Str) -> i32 = {
  prog: Program = parse(copy src)
  checked: Program = check(prog)
  c: Str = emit(checked)
  ok_write: bool = try_write_file(copy out, c)
  if !(copy ok_write) then copy EXIT_OUTPUT_WRITE else copy EXIT_OK
}

compile_input(input: Str, out: Str) -> i32 = {
  file_res: ReadFileResult = try_read_file(copy input)
  if !(copy file_res.ok) then copy EXIT_INPUT_READ
  else compile_source(copy file_res.data, copy out)
}

main() -> i32 = {
  a: ArgParse = parse_args()
  input: Str = copy a.input
  emit_c: Str = copy a.emit_c
  out: Str = if copy emit_c == "" then "target/self_host/gautc2.stage1.c" else emit_c

  if copy a.err == copy EXIT_OK then
    if copy input == "" then copy EXIT_USAGE else compile_input(copy input, copy out)
  else copy a.err
}
