import ast
import parser

emit_runtime_include() -> Str =
  "#include <stdint.h>\n"
  + "#include <stdbool.h>\n"
  + "#include <stddef.h>\n"
  + "#include <string.h>\n"
  + "#include \"runtime.h\"\n"
  + "\n"

emit_builtin_shims() -> Str =
  "typedef struct { bool ok; char* data; } ReadFileResult;\n"
  + "char* print(char* msg) { gaut_print(msg); return msg; }\n"
  + "char* println(char* msg) { gaut_println(msg); return msg; }\n"
  + "char* read_file(char* path) { return gaut_read_file(path); }\n"
  + "void write_file(char* path, char* data) { gaut_write_file(path, data); }\n"
  + "gaut_bytes args() { return gaut_args(); }\n"
  + "char* bytes_to_str(gaut_bytes b) { return gaut_bytes_to_str(b); }\n"
  + "ReadFileResult try_read_file(char* path) {\n"
  + "  ReadFileResult r;\n"
  + "  r.data = gaut_try_read_file(path, &r.ok);\n"
  + "  return r;\n"
  + "}\n"
  + "bool try_write_file(char* path, char* data) { return gaut_write_file(path, data) == 0; }\n"
  + "int32_t str_len(char* s) { return gaut_str_len(s); }\n"
  + "int32_t str_byte_at(char* s, int32_t i) { return gaut_str_byte_at(s, i); }\n"
  + "char* str_slice(char* s, int32_t start, int32_t len) { return gaut_str_slice(s, start, len); }\n"
  + "\n"

emit_scope_helpers() -> Str =
  "#define GAUT_FIELD(obj, field) ((obj).field)\n"
  + "#define GAUT_FIELD_REF(obj, field) ((obj)->field)\n"
  + "\n"

emit_decl_sorted(n: i32) -> Str =
  if copy n == 0 then "" else "  /* decls(sorted) */\n"

emit_program_body(prog: Program) -> Str =
  "int main(int argc, char** argv) {\n"
  + "  gaut_args_init(argc, argv);\n"
  + "  uint8_t __arena_buf[GAUT_DEFAULT_ARENA_CAP];\n"
  + "  gaut_arena __arena = gaut_arena_from_buffer(__arena_buf, GAUT_DEFAULT_ARENA_CAP);\n"
  + "  (void)__arena;\n"
  + emit_decl_sorted(prog.decls)
  + "  return 0;\n"
  + "}\n"

emit(prog: Program) -> Str =
  emit_runtime_include()
  + emit_builtin_shims()
  + emit_scope_helpers()
  + emit_program_body(prog)
